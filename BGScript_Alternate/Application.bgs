dim shots_taken # Counter to keep track of the number of shots taken during a time lapse sequence
dim shots_requested # Variable that is stored when the client updates us with a number of shots to take in the sequence (set in GATT server)
dim slide_zero_pwm # Timer1 PWM greyscale value, calibrated so that the sliding axis does not move
dim pwm_baseline # Baseline PWM setting that produces a 50 Hz timer frequency.
dim initializing # Flag to indicate that the slider is initializing (sliding axis moves to limit, yaw axis set to initial position)
dim interval # Value which is set from GATT server to specify the frequency of the soft timer (units of clock periods, operates at 32768 Hz). Maximum is 128 seconds.
dim exposure # Value which is set from GATT server to specify the duration of the one-shot timer (units of clock periods, operates at 32768 Hz)
dim status # variable describing the state of the system (0 - uninitialized, 1 - initialized, 2 - capturing sequence)
dim moving # variable to indicate motion of the sliding axis

# Boot event listener
event system_boot(major ,minor ,patch ,build ,ll_version ,protocol_version ,hw)
	#slider is not moving
	moving = 0
	# We haven't taken any photos yet
	shots_taken = 0
	call attributes_write(c_shots_taken, 0, 2, shots_taken)
	# No shots requested
	shots_requested = 0
	call attributes_write(c_shots_requested, 0, 2, shots_requested)
	# Expsure set to 30 seconds
	exposure = 30*32768
	call attributes_write(c_exposure_length, 0, 2, exposure)
	# Interval set to 45 seconds
	interval = 45*32768
	call attributes_write(c_shot_interval, 0, 2, interval)
	# Update status to reflect uninitialized state
	status = 0
	call attributes_write(c_slider_status, 0, 2, status)
	# Set the 'zero' pwm greyscale to 50%
	pwm_baseline = 5120
	slide_zero_pwm = pwm_baseline/2
	initializing = 0
	# Set advertisement interval to 20ms min, 30 ms max (units are 0.625 ms)
	# Use all three advertisement channels (7 = bitmask 0b00000111)
	call gap_set_adv_parameters(32, 48, 7)
	# Start advertising (discoverable/connectable)
	call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)

    call hardware_io_port_config_direction(0, 18)
	# enable interrupt on P1_3 and P1_4 rising edge
    # (parameters are port=0, bitmask=0b000011000, edge=falling)
    call hardware_io_port_config_irq(1, 18, 1)
    # Set shutter (P1_0) and focus (P1_1) as output
    # (port=1, pin mode mask = 0b00000011)
 	call hardware_io_port_config_direction(1, $02) # Set P0_0 pin HIGH
 	# Set shutter and focus pin outputs to zero
	# (port=1, pin selection mask = 0b00000011, pin logic mask = 0b00000000)
	call hardware_io_port_write(0, $02, $00)
end
 
# Connection event listener
event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
	# Device is connected
	# Do anything we want to happen here...
end

# Desconnection event listener
event connection_disconnected(connection, result)
	#connection disconnected, resume advertising
	call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
end


dim result
dim portread
dim data
dim out_handle
dim out_offset
dim out_value_len
# Catch an attribute write event from the phone...
event attributes_value(connection, reason, handle, offset, value_len, value_data)
	# This is to handle all user attributes changes.
	if handle = u_init then
		if value_data(0:1) = 1 then
			initializing = 1
			# Configure timer for PWM servo source...
			# 32.768 MHz chip, Timer1 set to divisor = 3 in hardware.xml
			# which divides by 128, so we end up with 256 kHz
			# and we want to get to 50 Hz for servo
			# So we set the comparator to flip every 5120 ticks, for 50 Hz
			# pwm_baseline is a variable set to 5120
			# Channel 0 (IO pin 1.2) is set as baseline frequency at 50 Hz:
			call hardware_timer_comparator(1, 0, 6, pwm_baseline)
			# Channel 1 (IO pin 1.3) is now the PWM output...
			# set to 50% (slide_zero_pwm = pwm_baseline/2)
			call hardware_timer_comparator(1,1,6,slide_zero_pwm)
			# Channel 2 (IO pin 1.4) is now the PWM output...
			# set to 0% !!Uncomment when we have a new board!!
			# call hardware_timer_comparator(1,2,6,0)

			# Check to see if we are at the limit...
			call hardware_io_port_read(1, $18)(result, portread, data)
			if data = $8 then
				# We have not hit any limit switch yet... run as needed.
				# Now move the sliding axis until we reach the negative limit switch
				# Set duty cycle to 25% (pwm_baseline/4)
				# This will cause our continuous rotation servo to move negative indefinitely
				# (until we catch the limit switch input low transition)
				# We should add in capability to start from the other direction, too...
				call hardware_timer_comparator(1,1,6,(pwm_baseline/4))
				while initializing = 1
					# Twiddle our thumbs waiting for the limit switch to be hit...
				end while
				# The slide axis has reached the limit switch.
			else
				# Already at the limit! Don't do anything.
			end if
			# !!!!!!!! remember to add in capability for the other direction.
			
			# Reset the GATT initialize trigger. This has the indicate property.
			# This pushes the updated attribute to the client.
			call attributes_write(u_init, 0, 1, 0)
			# Finished initializing!
			# Update status to reflect initialized state
			status = 1
			call attributes_write(c_slider_status, 0, 2, status)
		end if
	end if

	if handle = u_trigger_sequence then
		# Start acquisition sequence here...
		if status = 1 then
			# Only start this sequence if we have initialized our axes...
			if value_data(0:1) = 1 then
				# Notify that we have taken no shots yet.
				shots_taken = 0
				call attributes_write(c_shots_taken, 0, 2, shots_taken)
				# Get the number of ticks we need to wait for the interval and exposure...
				call attributes_read(c_shot_interval, 0)(out_handle, out_offset, result, out_value_len, interval)
				call attributes_read(c_exposure_length, 0)(out_handle, out_offset, result, out_value_len, exposure)
				call attributes_read(c_shots_requested, 0)(out_handle, out_offset, result, out_value_len, shots_requested)
				# Do some basic error checking... Do nothing if it doesn't make sense...
				if (interval - exposure) < 1 then # We need at least one second downtime...
					call attributes_write(c_error_code, 0, 2, $01)
					return
				end if
				if shots_requested < 2 then # We need at least two photos to take.
					call attributes_write(c_error_code, 0, 2, $02)
					return
				end if
				# Now set the flag to start the sequence...
				status = 2
				# Update status from 1 to 2, to indicate that we are currently in sequence.
				call attributes_write(c_slider_status, 0, 2, status)
				# configure soft timer for 1 second intervals (32768 Hz crystal, interval = 32768/32768)
				# This timer is used for triggering photos (clock cycles per tick, timer handle, 0 - continuous)
			    call hardware_set_soft_timer(interval, 1, 0)
			end if
		end if
	end if
end

# catch limit switch event P1_3, P1_4 (active LOW configuration)
event hardware_io_port_status(delta, port, irq, state)
    if port = 1 then
        if (irq & $8) = 0 then
            # P1_3 is LOW and the source of this interrupt
            # Stop slider motion...
			call hardware_timer_comparator(1,1,6,slide_zero_pwm)
			initializing = 0
        end if
        if (irq & $10) = 0 then
            # P1_4 is LOW and the source of this interrupt
            # Stop slider motion...
			call hardware_timer_comparator(1,1,6,slide_zero_pwm)
			initializing = 0
        end if
    end if
end

# catch timer ticks. This handles both the continous timer, and the one shot timer that moves the camera.
event hardware_soft_timer(handle)
	if handle = 1 then # Continuous timer event
		if status = 2 then
			# Check for an update on the number of ticks we need to wait for the interval and exposure and shot count...
			call attributes_read(c_shot_interval, 0)(out_handle, out_offset, result, out_value_len, interval)
			call attributes_read(c_exposure_length, 0)(out_handle, out_offset, result, out_value_len, exposure)
			call attributes_read(c_shots_requested, 0)(out_handle, out_offset, result, out_value_len, shots_requested)
			if moving = 1
				# Twiddle our thumbs waiting for the slide axis to finish moving...
				# I hope this doesn't block...
			end if
			# Start the exposure...
			call hardware_io_port_write(0, $01, $01)
			# Use a one-shot timer to end the exposure...
			# Exposure, timer handle = 2, single shot
			call hardware_set_soft_timer(exposure, 2, 1)
		end if
	end if

	if handle = 2 # One-shot timer event, handles the exposure timer
		# End the exposure... this only works while camera is in bulb mode. Otherwise it just takes the specified exposure.
		call hardware_io_port_write(0, $01, $00)
		# Update the number of shots taken...
		shots_taken = shots_taken + 1
		call attributes_write(c_shots_taken, 0, 2, shots_taken)
		#Check to see if we are finished...
		if shots_taken = shots_requested then
			# Finished with sequence!
			status = 0
			# Turn off timer handle 1 by setting cycles to 0 (clock cycles per tick, timer handle, 0 - continuous)
			call hardware_set_soft_timer(0, 1, 0)
			return
		end if
		# Move to the next shot location!!!
		# To adjust the distance the camera moves for each shot:
		#	Configure the PWM greyscale to adjust speed of servo
		#	Configure the one-shot timer delay to adjust the span of time the servo moves the camera
		# We need to make sure that this timer event waits while we are moving, so we have a moving flag we need to set...
		moving = 1
		# Set output pwm to 3/4 greyscale (or whatever):
		call hardware_timer_comparator(1,1,6,(pwm_baseline*3/4))
		# Use a one-shot timer to move the slide axis. For the yaw axis (when implimented) just move to the next PWM greyscale position.
		# 0.5 second, timer handle = 3, single shot
		call hardware_set_soft_timer(16384, 3, 1)
	end if

	if handle = 3 # One-shot timer event, handles the motion timer
		# Set PWM output to 50% duty cycle, which should stop servo rotation.
		call hardware_timer_comparator(1,1,6,slide_zero_pwm)
		# Ok, set the moving flag back to zero so we can process repeating timer handle 1's events again.
		moving = 0
	end if
end