dim shots_taken # Counter to keep track of the number of shots taken during a time lapse sequence
dim shots_requested # Variable that is stored when the client updates us with a number of shots to take in the sequence (set in GATT server)
# This baseline frequency is set by n periods of the harware timer clock (32,768,000 Hz, with divisor of 32, resulting in 1024 kHz)
# n = 1,024,000/(Desired Frequency, 50), so n = 102400/50 = 20480
const pwm_baseline = 20480 # Baseline PWM setting that produces a 50 Hz timer frequency.
# Set the 'zero' pwm greyscale to 50% (20480/2). Tune as necessary when hardware is ready for testing
const slide_zero_pwm = 10240 # Timer1 zero movement PWM greyscale value (0 to 20480), calibrated so that the sliding axis does not move
dim initializing # Flag to indicate that the slider is initializing (sliding axis moves to limit, yaw axis set to initial position)
dim interval # Value which is set from GATT server to specify the frequency of the soft timer (units of clock periods, operates at 32768 Hz). Maximum is 128 seconds.
dim exposure # Value which is set from GATT server to specify the duration of the one-shot timer (units of clock periods, operates at 32768 Hz)
dim status # variable describing the state of the system (0 - uninitialized, 1 - initialized, 2 - capturing sequence)
dim moving # variable to indicate motion of the sliding axis

# Boot event listener
event system_boot(major ,minor ,patch ,build ,ll_version ,protocol_version ,hw)
	#slider is not moving
	moving = 0
	# We haven't taken any photos yet
	shots_taken = 0
	call attributes_write(c_shots_taken, 0, 2, shots_taken)
	# No shots requested
	shots_requested = 0
	call attributes_write(c_shots_requested, 0, 2, shots_requested)
	# Expsure set to 30 seconds
	exposure = 30*32768
	call attributes_write(c_exposure_length, 0, 2, exposure)
	# Interval set to 45 seconds
	interval = 45*32768
	call attributes_write(c_shot_interval, 0, 2, interval)
	# Update status to reflect uninitialized state
	status = 0
	call attributes_write(c_slider_status, 0, 2, status)
	initializing = 0
	# Set advertisement interval to 20ms min, 30 ms max (units are 0.625 ms)
	# Use all three advertisement channels (7 = bitmask 0b00000111)
	call gap_set_adv_parameters(32, 48, 7)
	# Start advertising (discoverable/connectable)
	call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
	# enable interrupt on P1_3 and P1_4 rising edge
	# (parameters are port=1, bitmask=0b000011000=18, edge=falling)
	call hardware_io_port_config_irq(1, 18, 1)
	# Set shutter (P1_0) and focus (P1_1) as output
	# (port=1, pin mode mask = 0b00000011)
	call hardware_io_port_config_direction(1, $02) # Set P0_0 pin HIGH
	# Set shutter and focus pin outputs to zero
	# (port=1, pin selection mask = 0b00000011, pin logic mask = 0b00000000)
	call hardware_io_port_write(0, $02, $00)
	# Configure timer for PWM servo source...
	# 32.768 MHz chip, Timer1 set to divisor = 3 in hardware.xml
	# which divides by 128, so we end up with 256 kHz
	# and we want to get to 50 Hz for servo
	# So we set the comparator to flip every 5120 ticks, for 50 Hz
	# pwm_baseline is a variable set to 5120
	# Channel 0 (IO pin 1.2) is set as baseline frequency at 50 Hz:
	call hardware_timer_comparator(1, 0, 6, pwm_baseline)
	# Channel 1 (IO pin 1.3) is now the PWM output...
	# set to 50% (slide_zero_pwm = pwm_baseline/2)
	call hardware_timer_comparator(1,1,6,slide_zero_pwm)
	# Channel 2 (IO pin 1.4) is now the PWM output...
	# set to 0% !!Uncomment when we have a new board!!
	# call hardware_timer_comparator(1,2,6,0)
end

# Connection event listener
event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
	# Device is connected
	# Do anything we want to happen here...
end

# Desconnection event listener
event connection_disconnected(connection, result)
	#connection disconnected, resume advertising
	call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
end


# Procedure for moving the sliding axis.
# Pass in non-zero PWM offset for motion.
# This procedure checks to make sure we haven't hit a limit switch before moving.
# If we are in the middle of a sequence, and have run into the end limit switch,
# this ignores the request. Which is good, the system keeps running as before
# but doesn't move. 
dim result
dim portread
dim data
procedure MoveSlider(offset)
	if offset > 0
		# Motion in the positive direction.
		# Check to see if we are at the positive limit...
		call hardware_io_port_read(1, $10)(result, portread, data)
		if data = $10 then
			# We are not at the limit (active low limit)
			call hardware_timer_comparator(1,1,6,(slide_zero_pwm + offset))
		end if
	end if
	if offset < 0
		# Motion in the negative direction.
		# Check to see if we are at the negative limit...
		call hardware_io_port_read(1, $8)(result, portread, data)
		if data = $8 then
			# We are not at the limit (active low limit)
			call hardware_timer_comparator(1,1,6,(slide_zero_pwm + offset))
		end if
	end if
	if offset = 0
		# Stop motion, don't bother checking for limits.
		call hardware_timer_comparator(1,1,6,slide_zero_pwm)
	end if
end


dim out_handle
dim out_offset
dim out_value_len
# Catch an attribute write event from the phone...
event attributes_value(connection, reason, handle, offset, value_len, value_data)
	# The GATT server received a u_init 0 to 1 transition.
	if handle = u_init then
		if value_data(0:1) = 1 then
			# Set a flag to let the limit switch interrupts know we are initialzing the slide axis...
			initializing = 1
			# Now move the sliding axis until we reach the negative limit switch
			# At some point add in capability to initialize to the other side of the slider.
			call MoveSlider(-100)
			# When the slide axis reaches the limit switch, the interrupt event is triggered.
			# The initializing flag let's the interrupt event know that it needs to tell the client
			# that the system is now initialized.
		end if
	end if
	# The GATT server received a u_start_trigger 0 to 1 transition.
	if handle = u_trigger_sequence then
		# Start acquisition sequence here...
		if status = 1 then
			# Only start this sequence if we have initialized our axes...
			if value_data(0:1) = 1 then
				# Notify that we have taken no shots yet.
				shots_taken = 0
				call attributes_write(c_shots_taken, 0, 2, shots_taken)
				# Get the number of ticks we need to wait for the interval and exposure...
				call attributes_read(c_shot_interval, 0)(out_handle, out_offset, result, out_value_len, interval)
				call attributes_read(c_exposure_length, 0)(out_handle, out_offset, result, out_value_len, exposure)
				call attributes_read(c_shots_requested, 0)(out_handle, out_offset, result, out_value_len, shots_requested)
				# Do some basic error checking... Do nothing if it doesn't make sense...
				if (interval - exposure) < 1 then # We need at least one second downtime...
					call attributes_write(c_error_code, 0, 2, $01)
					return
				end if
				if shots_requested < 2 then # We need at least two photos to take.
					call attributes_write(c_error_code, 0, 2, $02)
					return
				end if
				# Now set the flag to start the sequence...
				status = 2
				# Update status from 1 to 2, to indicate that we are currently in sequence.
				call attributes_write(c_slider_status, 0, 2, status)
				# configure soft timer for 1 second intervals (32768 Hz crystal, interval = 32768/32768)
				# This timer is used for triggering photos (clock cycles per tick, timer handle, 0 - continuous)
			    call hardware_set_soft_timer(interval, 1, 0)
			end if
		end if
	end if
end

# catch limit switch event P1_3, P1_4 (active LOW configuration)
event hardware_io_port_status(delta, port, irq, state)
	if port = 1 then
		if (irq & $8) = 0 then
			# P1_3 is LOW and the source of this interrupt
			# Stop slider motion...
			call MoveSlider(0)
			if initializing = 1 then
				# We are initializing the sliding axis (moving it to 'zero').
				# The axis hit the limit switch. We're initialized.
				initializing = 0
				# Reset the GATT initialize trigger. This has the indicate property.
				# This pushes the updated attribute to the client.
				call attributes_write(u_init, 0, 1, 0)
				# Finished initializing!
				# Update status to reflect initialized state
				status = 1
				call attributes_write(c_slider_status, 0, 2, status)
			end if
		end if
		if (irq & $10) = 0 then
			# P1_4 is LOW and the source of this interrupt
			# Stop slider motion...
			call MoveSlider(0)
			if initializing = 1 then
				initializing = 0
				# Reset the GATT initialize trigger. This has the indicate property.
				# This pushes the updated attribute to the client.
				call attributes_write(u_init, 0, 1, 0)
				# Finished initializing!
				# Update status to reflect initialized state
				status = 1
				call attributes_write(c_slider_status, 0, 2, status)
			end if
		end if
	end if
end

# catch timer ticks. This handles both the continous timer, and the one shot timer that moves the camera.
event hardware_soft_timer(handle)
	if handle = 1 then # Continuous timer event
		if status = 2 then
			# Check for an update on the number of ticks we need to wait for the interval and exposure and shot count...
			call attributes_read(c_shot_interval, 0)(out_handle, out_offset, result, out_value_len, interval)
			call attributes_read(c_exposure_length, 0)(out_handle, out_offset, result, out_value_len, exposure)
			call attributes_read(c_shots_requested, 0)(out_handle, out_offset, result, out_value_len, shots_requested)
			# Start the exposure...
			call hardware_io_port_write(0, $01, $01)
			# Use a one-shot timer to end the exposure...
			# Exposure, timer handle = 2, single shot
			call hardware_set_soft_timer(exposure, 2, 1)
		end if
	end if

	if handle = 2 # One-shot timer event, handles the exposure timer
		# End the exposure... this only works while camera is in bulb mode. Otherwise it just takes the specified exposure.
		call hardware_io_port_write(0, $01, $00)
		# Update the number of shots taken...
		shots_taken = shots_taken + 1
		call attributes_write(c_shots_taken, 0, 2, shots_taken)
		#Check to see if we are finished...
		if shots_taken = shots_requested then
			# Finished with sequence!
			status = 0
			# Turn off timer handle 1 by setting cycles to 0 (clock cycles per tick, timer handle, 0 - continuous)
			call hardware_set_soft_timer(0, 1, 0)
			return
		end if
		# Move to the next shot location!!!
		# To adjust the distance the camera moves for each shot:
		#	Configure the PWM greyscale to adjust speed of servo
		#	Configure the one-shot timer delay to adjust the span of time the servo moves the camera
		# We need to make sure that this timer event waits while we are moving, so we have a moving flag we need to set...
		moving = 1
		# Change PWM output by some positive offset...
		call MoveSlider(1000)
		# Use a one-shot timer to move the slide axis. For the yaw axis (when implimented) just move to the next PWM greyscale position.
		# 0.5 second, timer handle = 3, single shot
		call hardware_set_soft_timer(16384, 3, 1)
	end if

	if handle = 3 # One-shot timer event, handles the motion timer
		# Stop servo motion
		call MoveSlider(0)
		# Ok, set the moving flag back to zero so we can process repeating timer handle 1's events again.
		moving = 0
	end if
end
