dim shots_taken
dim shots_requested
dim slide_zero_pwm
dim pwm_baseline
dim initializing
dim interval_ticks
dim exposure_ticks
dim elapsed_ticks
dim status
# Boot event listener
event system_boot(major ,minor ,patch ,build ,ll_version ,protocol_version ,hw)
	# We haven't taken any photos yet
	shots_taken = 0
	call attributes_write(c_shots_taken, 0, 2, shots_taken)
	# No shots requested
	shots_requested = 0
	call attributes_write(c_shots_requested, 0, 2, shots_requested)
	# Set timer ticks to 0...
	elapsed_ticks = 0
	# Expsure set to 30 seconds
	exposure_ticks = 30
	call attributes_write(c_exposure_length, 0, 2, exposure_ticks)
	# Interval set to 45 seconds
	interval_ticks = 45
	call attributes_write(c_shot_interval, 0, 2, interval_ticks)
	# Update status to reflect uninitialized state
	status = 0
	call attributes_write(c_slider_status, 0, 2, status)
	# Set the 'zero' pwm greyscale to 50%
	pwm_baseline = 5120
	slide_zero_pwm = 5120/2
	initializing = 0
	# Set advertisement interval to 20ms min, 30 ms max (units are 0.625 ms)
	# Use all three advertisement channels (7 = bitmask 0b00000111)
	call gap_set_adv_parameters(32, 48, 7)
	# Start advertising (discoverable/connectable)
	call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)

    call hardware_io_port_config_direction(0, 18)
	# enable interrupt on P1_3 and P1_4 rising edge
    # (parameters are port=0, bitmask=0b000011000, edge=falling)
    call hardware_io_port_config_irq(1, 18, 1)
    # Set shutter (P1_0) and focus (P1_1) as output
    # (port=1, pin mode mask = 0b00000011)
 	call hardware_io_port_config_direction(1, $02)# Set P0_0 pin HIGH
 	# Set shutter and focus pin outputs to zero
	# (port=1, pin selection mask = 0b00000011, pin logic mask = 0b00000000)
	call hardware_io_port_write(0, $02, $00)
	# configure soft timer for 1 second intervals (32768 Hz crystal, interval = 32768/32768)
	# This timer is used for triggering photos
    call hardware_set_soft_timer(32768, 1, 0)
end
 


# Connection event listener
event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
	# Device is connected
	# Do anything we want to happen here...
end

# Desconnection event listener
event connection_disconnected(connection, result)
	#connection disconnected, resume advertising
	call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
end


dim result
dim portread
dim data
dim out_handle
dim out_offset
dim out_value_len
# Catch an attribute write event from the phone...
event attributes_value(connection, reason, handle, offset, value_len, value_data)
	# This is to handle all user attributes changes.
	if handle = u_init then
		if value_data(0:1) = 1 then
			initializing = 1
			# Configure timer for PWM servo source...
			# 32.768 MHz chip, Timer1 set to divisor = 3 in hardware.xml
			# which divides by 128, so we end up with 256 kHz
			# and we want to get to 50 Hz for servo
			# So we set the comparator to flip every 5120 ticks, for 50 Hz
			# pwm_baseline is a variable set to 5120
			# Channel 0 (IO pin 1.2) is set as baseline frequency at 50 Hz:
			call hardware_timer_comparator(1, 0, 6, pwm_baseline)
			# Channel 1 (IO pin 1.3) is now the PWM output...
			# set to 50% (slide_zero_pwm = pwm_baseline/2)
			call hardware_timer_comparator(1,1,6,slide_zero_pwm)
			# Channel 2 (IO pin 1.4) is now the PWM output...
			# set to 0% !!Uncomment when we have a new board!!
			# call hardware_timer_comparator(1,2,6,0)

			# Check to see if we are at the limit...
			call hardware_io_port_read(1, $18)(result, portread, data)
			if data = $8 then
				# We have not hit any limit switch yet... run as needed.
				# Now move the sliding axis until we reach the negative limit switch
				# Set duty cycle to 25% (pwm_baseline/4)
				# This will cause our continuous rotation servo to move negative indefinitely
				# (until we catch the limit switch input low transition)
				# We should add in capability to start from the other direction, too...
				call hardware_timer_comparator(1,1,6,(pwm_baseline/4))
				while initializing = 1
					# Twiddle our thumbs waiting for the limit switch to be hit...
				end while
				# The slide axis has reached the limit switch.
			else
				# Already at the limit! Don't do anything.
			end if
			# !!!!!!!! remember to add in capability for the other direction.
			
			# Reset the GATT initialize trigger. This has the indicate property.
			# This pushes the updated attribute to the client.
			call attributes_write(u_init, 0, 1, 0)
			# Finished initializing!
			# Update status to reflect initialized state
			status = 1
			call attributes_write(c_slider_status, 0, 2, status)
		end if
	end if

	if handle = u_trigger_sequence then
		# Start acquisition sequence here...
		if status = 1 then
			# Only start this sequence if we have initialized our axes...
			if value_data(0:1) = 1 then
				# Notify that we have taken no shots yet.
				shots_taken = 0
				call attributes_write(c_shots_taken, 0, 2, shots_taken)
				# Get the number of ticks we need to wait for the interval and exposure...
				call attributes_read(c_shot_interval, 0)(out_handle, out_offset, result, out_value_len, interval_ticks)
				call attributes_read(c_exposure_length, 0)(out_handle, out_offset, result, out_value_len, exposure_ticks)
				call attributes_read(c_shots_requested, 0)(out_handle, out_offset, result, out_value_len, shots_requested)
				# Do some basic error checking... Do nothing if it doesn't make sense...
				if (interval_ticks - exposure_ticks) < 1 then # We need at least one second downtime...
					call attributes_write(c_error_code, 0, 2, $01)
					return
				end if
				if shots_requested < 2 then # We need at least two photos to take.
					call attributes_write(c_error_code, 0, 2, $02)
					return
				end if
				# Now set the flag to start the sequence...
				status = 2
				# Update status from 1 to 2, to indicate that we are currently in sequence.
				call attributes_write(c_slider_status, 0, 2, status)
			end if
		end if
	end if
end

# catch limit switch event P1_3, P1_4 (active LOW configuration)
event hardware_io_port_status(delta, port, irq, state)
    if port = 1 then
        if (irq & $8) = 0 then
            # P1_3 is LOW and the source of this interrupt
            # Stop slider motion...
			call hardware_timer_comparator(1,1,6,slide_zero_pwm)
			initializing = 0
        end if
        if (irq & $10) = 0 then
            # P1_4 is LOW and the source of this interrupt
            # Stop slider motion...
			call hardware_timer_comparator(1,1,6,slide_zero_pwm)
			initializing = 0
        end if
    end if
end

# catch timer tick for shutter timing...
event hardware_soft_timer(handle)
	if status = 2 then
		if elapsed_ticks = 0 then
			# Start the exposure...
			call hardware_io_port_write(0, $01, $01)
		end if
		if elapsed_ticks = exposure_ticks then
			# End the exposure...
			call hardware_io_port_write(0, $01, $00)
			# Update the number of shots taken...
			shots_taken = shots_taken + 1
			call attributes_write(c_shots_taken, 0, 2, shots_taken)
			# Check for an update on the number of ticks we need to wait for the interval and exposure and shot count...
			call attributes_read(c_shot_interval, 0)(out_handle, out_offset, result, out_value_len, interval_ticks)
			call attributes_read(c_exposure_length, 0)(out_handle, out_offset, result, out_value_len, exposure_ticks)
			call attributes_read(c_shots_requested, 0)(out_handle, out_offset, result, out_value_len, shots_requested)
			# Move to the next shot location!!!
			# Use a one-shot timer to move the slide axis. For the yaw axis (when implimented) just move to the next PWM greyscale position.
		end if
		if elapsed_ticks = interval_ticks then
			# Reset elapsed ticks
			elapsed_ticks = 0
		else
			# Increment elapsed ticks
			elapsed_ticks = elapsed_ticks + 1
		end if
		if shots_taken = shots_requested then
			# Finished with sequence!
			status = 0
		end if
	else
		elapsed_ticks = 0
	end if
end